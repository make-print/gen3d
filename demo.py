import base64
import logging
import os
import threading
import time
import tkinter as tk
from tkinter import scrolledtext
from typing import Optional

import cv2
import numpy as np
import openai
import pyautogui
import pygetwindow as gw
import yaml
from dotenv import load_dotenv
from langchain.schema import HumanMessage
from langchain_community.chat_models import ChatOpenAI

# Load environment variables from .env file
load_dotenv()

OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
if not OPENAI_API_KEY:
    logging.error("OpenAI API key not found. Please set the OPENAI_API_KEY environment variable.")
    exit(1)

openai.api_key = OPENAI_API_KEY


class GPTInterface:
    """
    Interface for interacting with the GPT-4 model.

    This class provides methods to interact with the GPT-4 model, allowing
    you to send both text and image data to the model and receive a response.
    """

    def __init__(self, model_name: str = "gpt-4o"):
        """
        Initializes the GPTInterface with the specified model name.

        Args:
            model_name (str): The name of the GPT model to use. Defaults to "gpt-4o".
        """
        # Initialize the model with the specified name
        self.model = ChatOpenAI(model_name=model_name)
        self.system_message = HumanMessage(content="Please respond in plain text only, no markdown.")

    def process_input(self, text: str, image: Optional[np.ndarray] = None) -> str:
        """
        Processes the input text and optional image, sending them to the GPT model.

        Args:
            text (str): The text prompt to send to the model.
            image (Optional[np.ndarray]): The image (in NumPy array format) to include in the request (optional).

        Returns:
            str: The response content generated by the model.
        """
        # Prepare the message content, starting with the text input
        messages = [
            self.system_message,
            HumanMessage(content=[{"type": "text", "text": text}])  # Text input for the model
        ]

        # If an image is provided, encode it and add it to the message
        if image is not None:
            _, buffer = cv2.imencode('.png', image)
            encoded_image = base64.b64encode(buffer).decode('utf-8')

            # Append the image data to the messages list
            messages[1].content.append(
                {
                    "type": "image_url",
                    "image_url": {
                        "url": f"data:image/png;base64,{encoded_image}"
                    }
                }
            )

        # Send the prepared message to the GPT model and get the response
        response = self.model.invoke(messages)

        # Return the content of the response from the model
        return response.content


# class ChatGUI:
#     def __init__(self, root: tk.Tk, gpt_interface: GPTInterface, config: dict) -> None:
#         """
#         Initializes the ChatGUI with a root window and GPT-4 interface.
#
#         Args:
#             root (tk.Tk): The root Tkinter window.
#             gpt_interface (GPTInterface): An instance of the GPT-4 interface.
#             config (dict): Configuration dictionary containing window and capture settings.
#         """
#         self.capture_status = None
#         self.root = root
#         self.gpt_interface = gpt_interface
#
#         # Load configuration parameters
#         self.window_title = config["window_title"]
#         self.width = config["width"]
#         self.height = config["height"]
#         self.frame_rate = config["frame_rate"]
#         self.recordings_dir = "recordings"
#         self.screenshots_dir = "screenshots"
#         os.makedirs(self.recordings_dir, exist_ok=True)
#         os.makedirs(self.screenshots_dir, exist_ok=True)
#
#         # Set up the main window
#         self.root.title("Jinn CAD Assistant")
#         self.root.geometry("1440x600")
#
#         # Chat display area
#         self.chat_display = scrolledtext.ScrolledText(self.root, wrap=tk.WORD, state='disabled', font=("Arial", 14))
#         self.chat_display.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)
#
#         # Apply the custom color tag for Jinn's messages
#         self.chat_display.tag_config("jinn", foreground="#AA00FF")
#
#         # Text widget for typing user messages, with dynamic resizing
#         self.entry = tk.Text(self.root, font=("Arial", 14), height=4, wrap=tk.WORD)
#         self.entry.pack(padx=10, pady=5, fill=tk.X)
#         self.entry.bind("<Return>", self.send_message)
#         self.entry.bind("<KeyRelease>", self._resize_text_entry)  # Bind to KeyRelease to resize dynamically
#
#         # Send button
#         self.send_button = tk.Button(self.root, text="Send", font=("Arial", 14), bg="#AA00FF", fg="white",
#                                      command=self.send_message)
#         self.send_button.pack(pady=5, padx=10, side=tk.RIGHT)
#
#         # Add a label to show screen capture status
#         self.capture_status = tk.Label(self.root, text="Jinn cannot see", fg="red", font=("Arial", 10))
#         self.capture_status.pack(pady=5, padx=10)
#
#         # Start the periodic capture in a separate thread
#         threading.Thread(target=self.periodic_capture).start()
#
#     def send_message(self, event: Optional[tk.Event] = None) -> None:
#         """
#         Sends the user's message to GPT-4 and displays the response in the chat window.
#
#         Args:
#             event (Optional[tk.Event]): The event that triggered this function (if any).
#         """
#         user_message = self.entry.get("1.0", tk.END).strip()
#         if not user_message:
#             return  # Ignore empty messages
#
#         # Display user message in the chat window
#         self.display_message("You", user_message)
#
#         # Capture the latest screen region as per the configuration
#         latest_frame = self.capture_window()
#
#         # Send the message and the latest frame to GPT-4
#         response = self.gpt_interface.process_input(user_message, latest_frame)
#
#         # Display GPT-4's response in the chat window
#         self.display_message("Jinn", response)
#
#         # Clear the entry widget and reset its size
#         self.entry.delete("1.0", tk.END)
#         self._resize_text_entry()
#
#         # Prevent the default action (inserting a newline) if using the Enter key
#         if event:
#             return "break"
#
#     def _resize_text_entry(self, event: Optional[tk.Event] = None) -> None:
#         """
#         Resizes the text entry widget height based on the number of lines of text.
#         """
#         lines = int(self.entry.index('end-1c').split('.')[0])  # Count the number of lines
#         self.entry.config(height=lines + 1)  # Set the height to the number of lines plus a little buffer
#
#     def display_message(self, sender: str, message: str) -> None:
#         """
#         Displays a message in the chat window with a custom color for Jinn's messages.
#
#         Args:
#             sender (str): The sender of the message (e.g., "You" or "Jinn").
#             message (str): The message to display.
#         """
#         self.chat_display.configure(state='normal')
#
#         if sender == "Jinn":
#             # Use a custom color for Jinn's messages
#             self.chat_display.insert(tk.END, f"{sender}: {message}\n", "jinn")
#         else:
#             self.chat_display.insert(tk.END, f"{sender}: {message}\n")
#
#         self.chat_display.configure(state='disabled')
#         self.chat_display.yview(tk.END)
#
#     def capture_window(self) -> Optional[np.ndarray]:
#         """
#         Captures the specified window and returns the captured frame as a NumPy array.
#
#         Returns:
#             Optional[np.ndarray]: The captured frame as a NumPy array, or None if the window is not found.
#         """
#         try:
#             window = find_window(self.window_title)
#             x, y, win_width, win_height = window.left, window.top, window.width, window.height
#
#             # Capture screenshot of the specified window region
#             screenshot = pyautogui.screenshot(region=(x, y, win_width, win_height))
#             img = np.array(screenshot)
#             img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
#             img = cv2.resize(img, (self.width, self.height))
#
#             # If capture is successful, update the status label
#             self.capture_status.config(text="Jinn sees", fg="green")
#
#             return img
#         except Exception as e:
#             # If capture fails, update the status label
#             self.capture_status.config(text="Jinn cannot see", fg="red")
#             print(f"Error capturing window: {e}")
#             return None
#
#     def periodic_capture(self) -> None:
#         """
#         Periodically captures the specified window and saves the screenshots.
#
#         This method runs in a loop and captures the window at the specified frame rate.
#         """
#         frame_interval: float = 1.0 / self.frame_rate
#         next_frame_time: float = time.time() + frame_interval
#
#         while True:
#             try:
#                 frame = self.capture_window()
#                 if frame is not None:
#                     screenshot_filename = f"{self.screenshots_dir}/screenshot_.png"
#                     cv2.imwrite(screenshot_filename, frame)
#
#                 time.sleep(max(0, next_frame_time - time.time()))
#                 next_frame_time += frame_interval
#
#             except KeyboardInterrupt:
#                 break


class RoundedText(tk.Canvas):
    def __init__(self, parent, *args, **kwargs):
        # Extract the font and other text-specific options before initializing the Canvas
        font = kwargs.pop('font', None)
        text_height = kwargs.pop('height', 4)
        text_wrap = kwargs.pop('wrap', tk.WORD)

        # Initialize the Canvas
        tk.Canvas.__init__(self, parent, *args, **kwargs)

        self.configure(bg="white", highlightthickness=0, relief="flat")

        # Draw rounded rectangle
        self.rounded_rect = self.create_rounded_rectangle(5, 5, 695, 195, radius=20, fill="white", outline="#AA00FF")

        # Place a Text widget on top of the rounded rectangle
        self.text = tk.Text(self, font=font, height=text_height, wrap=text_wrap, bg="white", relief="flat")
        self.text.place(x=10, y=10, width=680, height=180)

    def create_rounded_rectangle(self, x1, y1, x2, y2, radius=25, **kwargs):
        points = [x1 + radius, y1,
                  x1 + radius, y1,
                  x2 - radius, y1,
                  x2 - radius, y1,
                  x2, y1,
                  x2, y1 + radius,
                  x2, y1 + radius,
                  x2, y2 - radius,
                  x2, y2 - radius,
                  x2, y2,
                  x2 - radius, y2,
                  x2 - radius, y2,
                  x1 + radius, y2,
                  x1 + radius, y2,
                  x1, y2,
                  x1, y2 - radius,
                  x1, y2 - radius,
                  x1, y1 + radius,
                  x1, y1 + radius,
                  x1, y1]

        return self.create_polygon(points, **kwargs, smooth=True)

    def bind(self, event, callback):
        self.text.bind(event, callback)

    def get(self, *args):
        return self.text.get(*args)

    def delete(self, *args):
        return self.text.delete(*args)

    def insert(self, *args):
        return self.text.insert(*args)


class ChatGUI:
    """
    A class to create a chat window GUI that interacts with GPT-4.

    This GUI allows users to type in prompts, send them to GPT-4, and display
    the responses in the chat window. The latest screen capture is included
    with each prompt.
    """

    def __init__(self, root: tk.Tk, gpt_interface: GPTInterface, config: dict) -> None:
        """
        Initializes the ChatGUI with a root window and GPT-4 interface.

        Args:
            root (tk.Tk): The root Tkinter window.
            gpt_interface (GPTInterface): An instance of the GPT-4 interface.
            config (dict): Configuration dictionary containing window and capture settings.
        """
        self.capture_status: Optional[tk.Label] = None
        self.root: tk.Tk = root
        self.gpt_interface: GPTInterface = gpt_interface

        # Load configuration parameters
        self.window_title: str = config["window_title"]
        self.width: int = config["width"]
        self.height: int = config["height"]
        self.frame_rate: int = config["frame_rate"]
        self.recordings_dir: str = "recordings"
        self.screenshots_dir: str = "screenshots"
        os.makedirs(self.recordings_dir, exist_ok=True)
        os.makedirs(self.screenshots_dir, exist_ok=True)

        # Set up the main window
        self.root.title("Jinn CAD Assistant")
        self.root.geometry("750x1300")

        # Chat display area
        self.chat_display: scrolledtext.ScrolledText = scrolledtext.ScrolledText(self.root, wrap=tk.WORD,
                                                                                 state='disabled', font=("Arial", 16))
        self.chat_display.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        # Apply the custom color tag for Jinn's messages
        self.chat_display.tag_config("jinn", foreground="#AA00FF")

        # Create a rounded Text widget for typing user messages
        self.entry: RoundedText = RoundedText(self.root, font=("Arial", 16), height=4, wrap=tk.WORD)
        self.entry.pack(padx=10, pady=5, fill=tk.X)
        self.entry.bind("<Return>", self.send_message)
        self.entry.bind("<KeyRelease>", self._resize_text_entry)  # Bind to KeyRelease to resize dynamically

        # Send button
        self.send_button: tk.Button = tk.Button(self.root, text="Send", font=("Arial", 16), bg="#AA00FF", fg="white",
                                                command=self.send_message)
        self.send_button.pack(pady=5, padx=10, side=tk.RIGHT)

        # Add a label to show screen capture status
        self.capture_status = tk.Label(self.root, text="Jinn cannot see", fg="red", font=("Arial", 12))
        self.capture_status.pack(pady=5, padx=10)

        # Start the periodic capture in a separate thread
        threading.Thread(target=self.periodic_capture).start()

    def send_message(self, event: Optional[tk.Event] = None) -> Optional[str]:
        """
        Sends the user's message to GPT-4 and displays the response in the chat window.

        Args:
            event (Optional[tk.Event]): The event that triggered this function (if any).

        Returns:
            Optional[str]: Returns "break" if triggered by an event to prevent default handling.
        """
        user_message: str = self.entry.get("1.0", tk.END).strip()
        if not user_message:
            return  # Ignore empty messages

        # Display user message in the chat window
        self.display_message("You", user_message)

        # Capture the latest screen region as per the configuration
        latest_frame: Optional[np.ndarray] = self.capture_window()

        # Display loading indicator
        self.loading_message: str = self.display_message("Jinn", "\n\nThinking...\n")

        # Start a separate thread to handle the GPT-4 response to avoid blocking the UI
        threading.Thread(target=self.get_response, args=(user_message, latest_frame)).start()

        # Clear the entry widget and reset its size
        self.entry.delete("1.0", tk.END)
        self._resize_text_entry()

        if event:
            return "break"

    def get_response(self, user_message: str, latest_frame: Optional[np.ndarray]) -> None:
        """
        Gets the response from GPT-4 and updates the chat window.

        Args:
            user_message (str): The user's input message.
            latest_frame (Optional[np.ndarray]): The latest screenshot of the target window.
        """
        response: str = self.gpt_interface.process_input(user_message, latest_frame)

        # Remove the loading message by deleting the text between the loading_message index and the end of the line
        self.chat_display.configure(state='normal')
        self.chat_display.delete(self.loading_message,
                                 f"{self.loading_message} + 1 lines")  # Remove the loading message
        self.display_message("Jinn", response)
        self.chat_display.configure(state='disabled')

    def _resize_text_entry(self, event: Optional[tk.Event] = None) -> None:
        """
        Resizes the text entry widget height based on the number of lines of text.

        Args:
            event (Optional[tk.Event]): The event that triggered this function (if any).
        """
        # Access the internal `tk.Text` widget directly
        lines: int = int(self.entry.text.index('end-1c').split('.')[0])  # Count the number of lines
        self.entry.text.config(height=lines + 1)  # Set the height to the number of lines plus a little buffer

    def display_message(self, sender: str, message: str) -> str:
        """
        Displays a message in the chat window with a custom color for Jinn's messages.

        Args:
            sender (str): The sender of the message (e.g., "You" or "Jinn").
            message (str): The message to display.

        Returns:
            str: The index at which the message was inserted.
        """
        self.chat_display.configure(state='normal')

        if sender == "Jinn":
            insert_index = self.chat_display.index(tk.END)  # Get the index before inserting
            self.chat_display.insert(tk.END, f"{sender}: {message}\n", "jinn")
        else:
            insert_index = self.chat_display.index(tk.END)  # Get the index before inserting
            self.chat_display.insert(tk.END, f"{sender}: {message}\n")

        self.chat_display.configure(state='disabled')
        self.chat_display.yview(tk.END)

        return insert_index  # Return the index where the message was inserted

    def capture_window(self) -> Optional[np.ndarray]:
        """
        Captures the specified window and returns the captured frame as a NumPy array.

        Returns:
            Optional[np.ndarray]: The captured frame as a NumPy array, or None if the window is not found.
        """
        try:
            window: gw.Window = find_window(self.window_title)
            x, y, win_width, win_height = window.left, window.top, window.width, window.height

            # Capture screenshot of the specified window region
            screenshot = pyautogui.screenshot(region=(x, y, win_width, win_height))
            img = np.array(screenshot)
            img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
            img = cv2.resize(img, (self.width, self.height))

            # If capture is successful, update the status label
            self.capture_status.config(text="Jinn sees", fg="green")
            return img
        except Exception as e:
            # If capture fails, update the status label
            self.capture_status.config(text="Jinn cannot see", fg="red")
            print(f"Error capturing window: {e}")
            return None

    def periodic_capture(self) -> None:
        """
        Periodically captures the specified window and saves the screenshots.

        This method runs in a loop and captures the window at the specified frame rate.
        """
        frame_interval: float = 1.0 / self.frame_rate
        next_frame_time: float = time.time() + frame_interval

        while True:
            try:
                frame = self.capture_window()
                if frame is not None:
                    screenshot_filename = f"{self.screenshots_dir}/screenshot_.png"
                    cv2.imwrite(screenshot_filename, frame)

                time.sleep(max(0, next_frame_time - time.time()))
                next_frame_time += frame_interval

            except KeyboardInterrupt:
                break


def find_window(title: str) -> gw.Window:
    """
    Finds a window whose title includes the specified substring.

    Args:
        title (str): The substring to search for in window titles.

    Returns:
        gw.Window: The window object that includes the specified title substring.

    Raises:
        Exception: If no window with the specified substring in its title is found.
    """
    windows = gw.getWindowsWithTitle(title)
    if windows:
        # If there's an exact match, return it first
        for window in windows:
            if title in window.title:
                return window

    raise Exception(f"find_window: No window with title including '{title}' found")


def main() -> None:
    """
    Main function to set up the chat interface and run the application.
    """
    # Load configuration from YAML file
    with open("config.yml", "r") as config_file:
        config = yaml.safe_load(config_file)

    # Initialize the GPT-4 interface
    gpt_interface = GPTInterface(model_name="gpt-4o")

    # Create the root Tkinter window
    root = tk.Tk()

    # Initialize the chat GUI
    chat_gui = ChatGUI(root, gpt_interface, config)

    # Run the Tkinter main loop
    root.mainloop()


if __name__ == "__main__":
    main()
